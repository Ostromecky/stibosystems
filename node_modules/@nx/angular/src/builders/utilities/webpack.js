"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveIndexHtmlTransformer = exports.resolveCustomWebpackConfig = exports.mergeCustomWebpackConfig = void 0;
const tslib_1 = require("tslib");
const webpack_merge_1 = require("webpack-merge");
const tsnode_register_1 = require("@nx/js/src/utils/typescript/tsnode-register");
function mergeCustomWebpackConfig(baseWebpackConfig, pathToWebpackConfig, options, target) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const customWebpackConfiguration = resolveCustomWebpackConfig(pathToWebpackConfig, options.tsConfig);
        // The extra Webpack configuration file can also export a Promise, for instance:
        // `module.exports = new Promise(...)`. If it exports a single object, but not a Promise,
        // then await will just resolve that object.
        const config = yield customWebpackConfiguration;
        // The extra Webpack configuration file can export a synchronous or asynchronous function,
        // for instance: `module.exports = async config => { ... }`.
        if (typeof config === 'function') {
            return config(baseWebpackConfig, options, target);
        }
        else {
            return (0, webpack_merge_1.merge)(baseWebpackConfig, config);
        }
    });
}
exports.mergeCustomWebpackConfig = mergeCustomWebpackConfig;
function resolveCustomWebpackConfig(path, tsConfig) {
    var _a;
    (0, tsnode_register_1.tsNodeRegister)(path, tsConfig);
    const customWebpackConfig = require(path);
    // If the user provides a configuration in TS file
    // then there are 2 cases for exporting an object. The first one is:
    // `module.exports = { ... }`. And the second one is:
    // `export default { ... }`. The ESM format is compiled into:
    // `{ default: { ... } }`
    return (_a = customWebpackConfig.default) !== null && _a !== void 0 ? _a : customWebpackConfig;
}
exports.resolveCustomWebpackConfig = resolveCustomWebpackConfig;
function resolveIndexHtmlTransformer(path, tsConfig, target) {
    var _a;
    (0, tsnode_register_1.tsNodeRegister)(path, tsConfig);
    const indexTransformer = require(path);
    const transform = (_a = indexTransformer.default) !== null && _a !== void 0 ? _a : indexTransformer;
    return (indexHtml) => transform(target, indexHtml);
}
exports.resolveIndexHtmlTransformer = resolveIndexHtmlTransformer;
