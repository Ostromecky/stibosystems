"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.verifyOrUpdateCloudBundle = void 0;
const crypto_1 = require("crypto");
const fs_1 = require("fs");
const path_1 = require("path");
const axios_1 = require("../utilities/axios");
const debug_logger_1 = require("./debug-logger");
function verifyOrUpdateCloudBundle(options) {
    return __awaiter(this, void 0, void 0, function* () {
        const runnerBundleInstallDirectory = getRunnerBundleInstallDirectory(options);
        const currentBundle = getLatestInstalledRunnerBundle(runnerBundleInstallDirectory);
        if (shouldVerifyInstalledRunnerBundle(runnerBundleInstallDirectory, currentBundle)) {
            const axios = (0, axios_1.createApiAxiosInstance)(options);
            const response = yield verifyCurrentBundle(axios, currentBundle);
            if (response.status !== 200 || response.data.valid) {
                (0, debug_logger_1.debugLog)('Currently installed bundle is valid');
                writeBundleVerificationLock(runnerBundleInstallDirectory);
                return currentBundle;
            }
            const { version, url } = response.data;
            (0, debug_logger_1.debugLog)('Currently installed bundle is invalid, downloading version', version, ' from ', url);
            return {
                version,
                fullPath: yield downloadAndExtractClientBundle(axios, runnerBundleInstallDirectory, version, url),
            };
        }
        return currentBundle;
    });
}
exports.verifyOrUpdateCloudBundle = verifyOrUpdateCloudBundle;
function getRunnerBundleInstallDirectory(options) {
    var _a;
    const cacheDirectory = (_a = options.cacheDirectory) !== null && _a !== void 0 ? _a : 'node_modules/.cache/nx';
    const runnerBundlePath = (0, path_1.join)(cacheDirectory, 'cloud');
    return runnerBundlePath;
}
function getLatestInstalledRunnerBundle(runnerBundleInstallDirectory) {
    if (!(0, fs_1.existsSync)(runnerBundleInstallDirectory)) {
        (0, fs_1.mkdirSync)(runnerBundleInstallDirectory, { recursive: true });
    }
    try {
        const installedBundles = (0, fs_1.readdirSync)(runnerBundleInstallDirectory)
            .filter((potentialDirectory) => {
            return (0, fs_1.statSync)((0, path_1.join)(runnerBundleInstallDirectory, potentialDirectory)).isDirectory();
        })
            .map((fileOrDirectory) => ({
            version: fileOrDirectory,
            fullPath: (0, path_1.join)(runnerBundleInstallDirectory, fileOrDirectory),
        }));
        if (installedBundles.length === 0) {
            // No installed bundles
            return null;
        }
        return sortCalVerDescending(installedBundles)[0];
    }
    catch (e) {
        console.log('Could not read runner bundle path:', e.message);
        return null;
    }
}
function shouldVerifyInstalledRunnerBundle(runnerBundleInstallDirectory, currentBundle) {
    // No bundle, need to download anyway
    if (currentBundle != null) {
        (0, debug_logger_1.debugLog)('A local bundle currently exists: ', currentBundle);
        const lastVerification = getLatestBundleVerificationTimestamp(runnerBundleInstallDirectory);
        // Never been verified, need to verify
        if (lastVerification != null) {
            // If last verification was less than 30 minutes ago, return the current installed bundle
            const THIRTY_MINUTES = 30 * 60 * 1000;
            if (Date.now() - lastVerification < THIRTY_MINUTES) {
                (0, debug_logger_1.debugLog)('Last verification was within the past 30 minutes, will not verify this time');
                return false;
            }
            (0, debug_logger_1.debugLog)('Last verification was more than 30 minutes ago, verifying bundle is still valid');
        }
    }
    return true;
}
function verifyCurrentBundle(axios, currentBundle) {
    return __awaiter(this, void 0, void 0, function* () {
        const contentHash = getBundleContentHash(currentBundle);
        const queryParams = currentBundle && contentHash
            ? `?${new URLSearchParams({
                version: currentBundle.version,
                contentHash: contentHash,
            }).toString()}`
            : '';
        return yield axios.get('/nx-cloud/client/verify' + queryParams);
    });
}
function getLatestBundleVerificationTimestamp(runnerBundleInstallDirectory) {
    const lockfilePath = (0, path_1.join)(runnerBundleInstallDirectory, 'verify.lock');
    if ((0, fs_1.existsSync)(lockfilePath)) {
        const timestampAsString = (0, fs_1.readFileSync)(lockfilePath, 'utf-8');
        let timestampAsNumber;
        try {
            timestampAsNumber = Number(timestampAsString);
            return timestampAsNumber;
        }
        catch (e) {
            return null;
        }
    }
    return null;
}
function writeBundleVerificationLock(runnerBundleInstallDirectory) {
    const lockfilePath = (0, path_1.join)(runnerBundleInstallDirectory, 'verify.lock');
    (0, fs_1.writeFileSync)(lockfilePath, new Date().getTime().toString(), 'utf-8');
}
function getBundleContentHash(bundle) {
    if (bundle == null) {
        return null;
    }
    return hashDirectory(bundle.fullPath);
}
function hashDirectory(dir) {
    const files = (0, fs_1.readdirSync)(dir).sort();
    const hashes = files.map((file) => {
        const filePath = (0, path_1.join)(dir, file);
        const stat = (0, fs_1.statSync)(filePath);
        // If the current path is a directory, recursively hash the contents
        if (stat.isDirectory()) {
            return hashDirectory(filePath);
        }
        // If it's a file, hash the file contents
        const content = (0, fs_1.readFileSync)(filePath);
        return (0, crypto_1.createHash)('sha256').update(content).digest('hex');
    });
    // Hash the combined hashes of the directory's contents
    const combinedHashes = hashes.sort().join('');
    return (0, crypto_1.createHash)('sha256').update(combinedHashes).digest('hex');
}
function sortCalVerDescending(versions) {
    return versions.sort((a, b) => {
        let aParts = a.version
            .split('.')
            .map((part, index) => index === 0 ? part.slice(0, 4) + '0' + part.slice(4) : part);
        let bParts = b.version
            .split('.')
            .map((part, index) => index === 0 ? part.slice(0, 4) + '0' + part.slice(4) : part);
        for (let i = 0; i < aParts.length; i++) {
            if (aParts[i] > bParts[i])
                return -1;
            if (aParts[i] < bParts[i])
                return 1;
        }
        return 0;
    });
}
function downloadAndExtractClientBundle(axios, runnerBundleInstallDirectory, version, url) {
    return __awaiter(this, void 0, void 0, function* () {
        let resp;
        try {
            resp = yield axios.get(url, {
                responseType: 'stream',
            });
        }
        catch (e) {
            console.error('Error while updating Nx Cloud client bundle');
            throw e;
        }
        const bundleExtractLocation = (0, path_1.join)(runnerBundleInstallDirectory, version);
        if (!(0, fs_1.existsSync)(bundleExtractLocation)) {
            (0, fs_1.mkdirSync)(bundleExtractLocation);
        }
        const tar = require('tar');
        const extractStream = resp.data.pipe(tar.x({
            cwd: bundleExtractLocation,
        }));
        return new Promise((res, rej) => {
            extractStream.on('error', (e) => {
                rej(e);
            });
            extractStream.on('close', () => {
                writeBundleVerificationLock(runnerBundleInstallDirectory);
                res(bundleExtractLocation);
            });
        });
    });
}
//# sourceMappingURL=update-manager.js.map